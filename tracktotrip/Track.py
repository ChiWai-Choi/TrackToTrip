import gpxpy
from os.path import basename
import matplotlib.pyplot as plt
from .segment import Segment
from copy import deepcopy

DEFAULT_FILE_NAME_FORMAT = "%Y-%m-%d"

# TODO: order each segment by starting date

class Track:
    """Collection of segments

    This is a higher level class, all methods of TrackToTrip library
    can be called over this class

    Attributes:
        name: A string indicating the name of the track
        segments: Array of TrackToTrip Segments
        preprocessed: Boolean, true if it has been preprocessed
    """

    def __init__(self, name="", segments=[]):
        """Constructor

        When constructing a track it's not guaranteed that the segments
        have their properties computed. Call preprocess method over this
        class, or over each segment to guarantee it.

        Args:
            name: optional, name of the current track. The default value
                is a empty string
            segments: optional, array of TrackToTripSegments. The default
                value is an empty array
        """
        self.name = name
        self.segments = segments
        self.preprocessed = False

    def segmentAt(self, i):
        """Segment at index

        Args:
            i: index of segment to return
        Returns:
            A TrackToTrip segment or an excption for index out of range
        """
        return self.segments[i]

    def generateName(self):
        """Generates a name for the track

        The name is generated based on the date of the first point of the
        track, or in case it doesn't exist, "EmptyTrack"
        The DEFAULT_FILE_NAME_FORMAT constant constains the date format

        Returns:
            A string of the generated name
        """
        if len(self.segments) > 0:
            return self.segmentAt(0).pointAt(0).time.strftime(DEFAULT_FILE_NAME_FORMAT) + ".gpx"
        else:
            return "EmptyTrack"

    def removeNoise(self, var=2):
        """In-place removal of noise points

        Arguments:
            var: Number to adjust noise removal sensitivity
        Returns:
            This track
        """
        for segment in self.segments:
            segment.removeNoise(var)
        return self

    def smooth(self):
        """In-place smoothing of segments

        Returns:
            This track
        """
        for segment in self.segments:
            segment.smooth()
        return self

    def segment(self):
        """In-place segmentation of segments

        Spatio-temporal segmentation of each segment
        The number of segments may increse after this step

        Returns:
            This track
        """
        newSegments = []
        for segment in self.segments:
            s = segment.segment()
            for a in s:
                newSegments.append(Segment(a))
        self.segments = newSegments
        return self

    def simplify(self):
        """In-place simplification of segments

        Returns:
            This track
        """
        for segment in self.segments:
            segment.simplify()
        return self

    def inferTransportationMode(self):
        """In-place transportation mode inferring of segments

        Returns:
            This track
        """
        for segment in self.segments:
            segment.inferTransportationMode()
        return self

    def copy(self):
        """Creates a deep copy of itself

        All segments and points are copied

        Returns:
            A Track object different from this instance
        """

        return deepcopy(self)

    def toTrip(self, name=""):
        """In-place, transformation of a track into a trip

        A trip is a more accurate depiction of reality than a
        track.
        For a track to become a trip it need to go through the
        following steps:
            + noise removal
            + smoothing
            + spatio-temporal segmentation
            + simplification
        At the end of these steps we have a less noisy, track
        that has less points, but that holds the same information.
        It's required that each segment has their metrics calculated
        or has been preprocessed.

        Args:
            name: An optional string with the name of the trip. If
                none is given, one will be generated by generateName
        Returns:
            This Track instance
        """
        if len(name) != 0:
            name = self.name
        else:
            name = self.generateName()

        self.removeNoise(2)
        self.smooth()
        self.segment()
        # for segment in self.segments:
            # plt.plot(map(lambda p: p.vel, segment.points))
        # plt.savefig("a.png", dpi=200, format='png', transparent=True, figsize=(10, 10))
        # self.simplify()
        self.name = name

        return self

    def preprocess(self):
        """In-place preprocessing of segments

        Returns:
            This track
        """
        self.segments = map(lambda segment: segment.preprocess(), self.segments)
        self.preprocessed = True
        return self

    def inferTransportationModes(self):
        """In-place transportation inferring of segments

        Returns:
            This track
        """
        self.segments = map(lambda segment: segment.inferTransportationMode(), self.segments)
        return self

    def inferLocation(self):
        """In-place location inferring of segments

        Returns:
            This track
        """
        self.segments = map(lambda segment: segment.inferLocation(), self.segments)
        return self

    def toJSON(self):
        """Converts track to a JSON serializable format

        Returns:
            Map with the name, and segments of the track.
        """
        return {
                'name': self.name,
                'segments': map(lambda segment: segment.toJSON(), self.segments)
                }

    def toGPX():
        """Converts track to a GPX format
        """
        # TODO
        print("toImplement")

    @staticmethod
    def fromGPX(filePath):
        """Creates a Track from a GPX file.

        No preprocessing is done.

        Arguments:
            filePath: file path and name to the GPX file
        Return:
            A Track instance
        """
        gpx = gpxpy.parse(open(filePath, 'r'))
        fileName = basename(filePath)

        tracks = []
        for ti, track in enumerate(gpx.tracks):
            segments = []
            for segment in track.segments:
                segments.append(Segment.fromGPX(segment))

            if len(gpx.tracks) > 1:
                name = fileName + "_" + str(ti)
            else:
                name = fileName
            tracks.append(Track(name, segments))

        return tracks

    @staticmethod
    def fromJSON(json):
        """Creates a Track from a JSON file.

        No preprocessing is done.

        Arguments:
            json: map with the keys: name (optional) and segments.
        Return:
            A track instance
        """
        segments = map(lambda s: Segment.fromJSON(s), json['segments'])
        return Track(json['name'], segments).preprocess()

